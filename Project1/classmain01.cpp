//#include <iostream>
//using namespace std;
//
////c++의 클래스(class)
////c++에서는 c언어에서 사용하던 구조체를 확장해 만든 클래스를 사용합니다.
////키워드 class를 통해 클래스를 설계하고, 클래스 내부에는 변수와 함수를 같이 보관해 사용할 수 있습니다.
//
////c언어의 구조체(struct)
////키워드 struct를 통해 변수를 만들면, 해당 변수 안에 변수를 만들어 관리하는 사용자 정의 타입
////c++에서는 c언어와의 호환성을 위해 남겨놓은 기능
//
//
//class student_cls
//{
//public :
//	string name;
//	int age;
//
//	//클래스 내부에는 함수를 만들 수 있습니다.
//	void action()
//	{
//
//	}
//private :
//	string address;
//
//};
//struct student_str
//{
//	string name;
//	int age:
//};
//
//
//
//int main()
//{
//	student_cls s_cls;  //클래스 선언
//	student_str s_str;  //구조체 선언
//
//
//	//구조체 안에 있는 변수(멤버변수) 사용
//	s_str.name = "이윤학";
//
//	//클래스 안에 있는 변수 사용
//	s_cls.name = "김기동";
//	//현재 오류가 나고 있다면 클래스에 만들어 놓은 변수가 비공개 상태이기 때문입니다.
//	//해결책 : 보여주고 싶은 부분을 public으로 감싸줍니다.
//	//public과 private를 통해 데이터에 대한 접근 여부를 설계할 수 있습니다.
//
//
//	student_cls s_cls2;
//	student_str s_str2;
//	s_cls2.name = "임철균";
//	s_str2.name = "김한솔";
//	//클래스 / 구조체가 가지고 있는 변수들은 주로 프로그램을 설계할때 자주 사용되는 이름들로 구성되어 있는 경우가 많습니다.
//	//일반적인 프로그래밍에서 변수의 이름은 1번만 설계가 가능하나, 클래스/구조체를 이용해 
//	//해당 클래스의 변수, 해당 구조체의 변수로 인식해 같은 이름의 변수를 사용할 수 있습니다.
//
//	//객체/ 절차/ 함수형 -> 프로그래밍 설계기법
//	//객체 지향 프로그래밍(oop : object oriented programming) : C++, 클래스
//	//객체(OBJECT) : 실생활에서 사용되는 모든 것들을 객체라고 정의합니다.
//	//프로그램을 구현하고자 할 때, 프로그램의 중심이 되고 프로그램에서 사용되는
//	//가장 중요한 핵심 데이터를 클래스를 통해 생성하고, 이를 하나의 객체로 보는 프로그램 설계 패러다임
//	//장점 : 코드에 대한 재사용, 확장이 쉬움
//	//       객체들간의 상호작용을 고려해 프로그램에 대한 모델링이 더 쉽게 이루어짐.
//	//       외부에 불필요한 정보를 은닉하여 보안성을 높일 수 있습니다.(클래스 특징)
//	//단점 : 절차지향에 비해 느린 속도를 가지고 있습니다.
//	//       객체가 많다는 건 즉 저장할 내용이 많다는 것, 
//	//       이건 결과호출로 처리하는 절차지향에 비해 메모리 코스트가 높은 편
//
//
//
//	
//	//절차 지향 프로그래밍(pp : procedural programming) : C, 함수, 포인터
//	//프로시저를 기반으로 작성하는 프로그래밍 설계방식을 의미합니다. 
//	// 프로시저(PROCEDURE)는 함수의 호출을 의미합니다.
//	// 프로그램의 순서와 흐름을 먼저 설계하고 필요한 자료 구조들과 함수를 설계하는 방식의
//	// 프로그래밍 설계 방법론입니다.
//	//장점 : 컴퓨터의 처리구조와 유사한 속도가 빠른 방식 실행 순서에 따라 구현하는 것이라 구현하는 것이 어렵지 않습니다.
//	//단점 : 디버깅(테스트)를 진행하기 어렵습니다. 유지보수가 어려운 방식
//	//       프로토콜(호출순서)에 따라 정해지기 때문에 코드의 순서가 바뀔 경우 동일 결과를 보장받기 어렵습니다.
//	
//	//함수형 프로그래밍(fp : functional programming) : 알고리즘, 람다식
//	//자료 처리 = 수학적인 함수의 계산
//	//특징 : 대입문은 사용하지 않습니다. 작은 문제를 해결하기 위한 함수를 작성합니다.
//	//함수형 프로그래밍에서 함수는 순수 함수로 설계하며 이를 1급 객체로 가능합니다.
//	//순수함수 : 부수효과(SIDE EFFECT)가 하나도 없는 함수
//	//부수 효과 : 변수의 값이 변경 / 예외, 오류가 발생해 실행 중단 / IO발생 / 자료구조 수정...
//	//1급 객체 : 변수나 데이터 구조안에 담을 수 있습니다. 파라미터로 전달이 가능, 
//	//           리턴값으로 사용할수 있음, 이름과 상관없이 구별이 가능함
//
//	//(알고리즘 설계 기법)
//	//동적 프로그래밍(dp : dynamic programming) : 동적 계획법, 배열(기존의 계산 값을 저장하기 위한 배열)
//	//  --> 기억하고 풀기
//	//하나의 큰 문제를 해결하기 위해 여러개의 작은 문제로 나누어서 그 결과를 저장하고 큰 문제를 해결하는 문제 해결 패러다임
//	// -> 코드에 대한 최적화
//	//+사용목적) : 동일한 문제가 여러번 반복되서 비효율적인 계산이 이루어지는 경우
//	//기존에 사용했던 값들을 저장해두고, 그 값이 나올때 작업을 하지 않도록 처리한다면 
//	//기존 값은 재사용하면서 연산을 반복할 필요가 없어 전체 반복 진행보다 효율적으로 처리를 진행할 수 있게 됩니다.
//	//+해당 방식으로 구현이 가능한 경우
//	//1. 작업이 겹치는 부분이 존재할 때
//	//2. 부분적인 선택으로 인해 전체 문제의 최적의 결과를 낼수 있는 경우
//	//+구현방식
//	//1. BOTTOM -UP : 아래에서 부터 계산을 수행해 누적시켜서 큰 문제를 해결합니다.
//	//2. TOP -DOWN : 위에서 부터 호출을 시작해 결과 값을 재귀를 통해 재활용 합니다.(재귀함수)
//
//
//
//
//	return 0;
//
//}